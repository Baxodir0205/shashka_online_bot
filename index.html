<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shashka Online - 5 Darajali AI</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: #2b4b6f;
            min-height: 100vh;
            padding: 10px;
        }

        .game-container {
            width: 100%;
            max-width: 400px;
            background: #34495e;
            border-radius: 25px;
            padding: 15px;
            margin: 0 auto;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }

        .game-title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #f1c40f;
            margin-bottom: 10px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .ai-level-info {
            background: #2c3e50;
            padding: 10px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border: 2px solid #f1c40f;
        }

        .ai-level-badge {
            background: #e67e22;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }

        .ai-level-name {
            color: #f1c40f;
            font-weight: bold;
            font-size: 16px;
        }

        .ai-level-desc {
            color: #bdc3c7;
            font-size: 12px;
            margin-top: 5px;
        }

        .players-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #2c3e50;
            padding: 10px;
            border-radius: 15px;
            margin-bottom: 15px;
            border: 1px solid #4a6782;
        }

        .player-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            flex: 1;
        }

        .player-label {
            font-size: 11px;
            color: #bdc3c7;
            text-transform: uppercase;
        }

        .player-name {
            font-weight: bold;
            font-size: 14px;
            color: #ecf0f1;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .player-rating {
            font-size: 11px;
            color: #f1c40f;
            font-weight: bold;
        }

        .vs-badge {
            background: #e67e22;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 12px;
            color: white;
        }

        .board-wrapper {
            background: #d35400;
            padding: 12px;
            border-radius: 20px;
            margin-bottom: 15px;
            box-shadow: inset 0 -3px 0 #a04000;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            aspect-ratio: 1/1;
            border: 3px solid #6b2e00;
            border-radius: 12px;
            overflow: hidden;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            cursor: pointer;
            position: relative;
        }

        .light {
            background: #f5e6d3;
        }

        .dark {
            background: #b06e4b;
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            font-size: 24px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 0 10px rgba(255,255,255,0.2);
        }

        .piece.white {
            background: #ffffff;
            border: 2px solid #e0e0e0;
            color: #333;
            box-shadow: 0 4px 0 #cccccc, 0 0 15px rgba(255,255,255,0.5);
        }

        .piece.black {
            background: #222222;
            border: 2px solid #444444;
            color: #fff;
            box-shadow: 0 4px 0 #000000, 0 0 15px rgba(0,0,0,0.5);
        }

        .piece.king::after {
            content: 'üëë';
            font-size: 20px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px #f1c40f, 0 4px 0 #b8860b;
            border: 3px solid #f1c40f !important;
            z-index: 10;
        }

        .hint {
            width: 20px;
            height: 20px;
            background: rgba(46, 204, 113, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border: 2px solid #27ae60;
            animation: pulse 1s infinite;
        }

        .capture-hint {
            width: 30px;
            height: 30px;
            background: rgba(231, 76, 60, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border: 2px solid #c0392b;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0.5; transform: translate(-50%, -50%) scale(0.8); }
        }

        .status-bar {
            background: #2c3e50;
            padding: 12px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 16px;
            color: #f1c40f;
            border: 1px solid #4a6782;
        }

        .buttons-panel {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
        }

        .btn-exit {
            background: #e67e22;
            color: white;
        }

        .btn-restart {
            background: #27ae60;
            color: white;
        }

        .winner-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
        }

        .winner-content {
            background: #34495e;
            padding: 25px;
            border-radius: 25px;
            text-align: center;
            border: 3px solid #f1c40f;
            max-width: 300px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .winner-content h2 {
            color: #f1c40f;
            font-size: 28px;
            margin-bottom: 10px;
        }

        .winner-content p {
            color: white;
            font-size: 20px;
            margin-bottom: 20px;
        }

        .winner-buttons {
            display: flex;
            gap: 10px;
        }

        .winner-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
        }

        .winner-btn.restart {
            background: #27ae60;
            color: white;
        }

        .winner-btn.exit {
            background: #e67e22;
            color: white;
        }

        .friends-container {
            background: #34495e;
            border-radius: 25px;
            padding: 20px;
            max-width: 400px;
            margin: 0 auto;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }

        .friends-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .friends-header h2 {
            color: #f1c40f;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .room-code {
            background: #2c3e50;
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 2px solid #f1c40f;
        }

        .room-code p {
            color: #ecf0f1;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .room-code .code {
            color: #f1c40f;
            font-size: 28px;
            font-weight: bold;
            letter-spacing: 5px;
        }

        .friends-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding: 5px;
        }

        .friend-item {
            background: #2c3e50;
            border-radius: 15px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #4a6782;
            transition: all 0.3s ease;
        }

        .friend-item.online {
            border-left: 5px solid #2ecc71;
        }

        .friend-item.offline {
            border-left: 5px solid #7f8c8d;
            opacity: 0.7;
        }

        .friend-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .friend-name {
            font-weight: bold;
            color: #ecf0f1;
            font-size: 16px;
        }

        .friend-rating {
            color: #f1c40f;
            font-size: 12px;
        }

        .friend-status {
            font-size: 11px;
        }

        .online .friend-status {
            color: #2ecc71;
        }

        .offline .friend-status {
            color: #7f8c8d;
        }

        .invite-btn {
            background: #e67e22;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #a04000;
        }

        .invite-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #a04000;
        }

        .invite-btn:disabled {
            background: #7f8c8d;
            box-shadow: 0 4px 0 #5a6268;
            cursor: not-allowed;
        }

        .back-btn {
            background: #3498db;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 15px;
            width: 100%;
            box-shadow: 0 4px 0 #2980b9;
        }

        .back-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #2980b9;
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #27ae60;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-weight: bold;
            z-index: 1000;
            animation: slideDown 0.3s ease;
            box-shadow: 0 4px 0 #1e8449;
        }

        @keyframes slideDown {
            from {
                top: -50px;
                opacity: 0;
            }
            to {
                top: 20px;
                opacity: 1;
            }
        }

        .loading {
            text-align: center;
            color: #f1c40f;
            padding: 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
        const tg = Telegram.WebApp;
        tg.expand();
        tg.ready();

        // URL parametrlarini olish
        const params = new URLSearchParams(window.location.search);
        const userId = params.get('user') || 'user_' + Math.random();
        const userName = params.get('name') || 'O\'yinchi';
        const mode = params.get('mode') || 'ai';
        const gameType = params.get('game') || 'checkers';
        const roomCode = params.get('room');
        const playerRole = params.get('player') || 'host';
        const aiLevel = parseInt(params.get('level') || '1');
        const hash = params.get('hash');

        // AI darajalari
        const aiLevels = {
            1: { name: 'Oson', icon: 'üá∂', desc: 'Yangi boshlovchi', color: '#27ae60', rating: 1200 },
            2: { name: 'O\'rtacha', icon: 'üá∞', desc: 'Oddiy o\'yinchi', color: '#3498db', rating: 1400 },
            3: { name: 'Qiyin', icon: 'üáØ', desc: 'Tajribali', color: '#e67e22', rating: 1600 },
            4: { name: 'Mutaxassis', icon: 'üá∂', desc: 'Usta', color: '#9b59b6', rating: 1800 },
            5: { name: 'Grandmaster', icon: 'üëë', desc: 'Professional', color: '#c0392b', rating: 2000 }
        };

        // WebApp ochilganda online statusini yuborish
        tg.sendData(JSON.stringify({
            action: 'user_online',
            user_id: userId,
            online: true,
            room_code: roomCode
        }));

        // WebApp yopilganda
        window.addEventListener('beforeunload', function() {
            tg.sendData(JSON.stringify({
                action: 'user_online',
                user_id: userId,
                online: false,
                room_code: roomCode
            }));

            if (mode === 'ai' && gameActive) {
                saveGameState();
            }
        });

        // O'yin holatini saqlash
        function saveGameState() {
            try {
                localStorage.setItem(`currentGame_${gameType}_${mode}_${aiLevel}`, JSON.stringify({
                    board: board,
                    currentPlayer: currentPlayer,
                    gameActive: gameActive,
                    timestamp: Date.now()
                }));
            } catch(e) {
                console.log('Saqlash xatosi:', e);
            }
        }

        // Xatoliklarni qayd qilish
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Xatolik:', msg, 'satr:', lineNo);
            tg.sendData(JSON.stringify({
                action: 'error_log',
                error: msg,
                line: lineNo,
                url: window.location.href,
                user_id: userId
            }));
            return false;
        };

        // Sahifani yuklash
        window.addEventListener('load', function() {
            if (mode === 'ai') {
                const savedGame = localStorage.getItem(`currentGame_${gameType}_${mode}_${aiLevel}`);
                if (savedGame) {
                    try {
                        const gameState = JSON.parse(savedGame);
                        if (gameState.board && Date.now() - gameState.timestamp < 3600000) {
                            board = gameState.board;
                            currentPlayer = gameState.currentPlayer;
                            gameActive = gameState.gameActive;
                        }
                    } catch(e) {
                        console.log('Saqlangan o\'yin topilmadi');
                    }
                }
            }
        });

        if (mode === 'friend' && !playerRole && !roomCode) {
            showFriendsList();
        } else {
            showGame();
        }

        async function showFriendsList() {
            const app = document.getElementById('app');
            app.innerHTML = `
                <div class="friends-container">
                    <div class="friends-header">
                        <h2>üë• DO'STLAR RO'YXATI</h2>
                    </div>
                    <div class="room-code">
                        <p>Xona kodi:</p>
                        <div class="code">${roomCode || 'XXXXXX'}</div>
                    </div>
                    <div id="friendsList" class="friends-list">
                        <div class="loading">‚è≥ Yuklanmoqda...</div>
                    </div>
                    <button class="back-btn" onclick="closeWebApp()">üîô Yopish</button>
                </div>
            `;

            tg.sendData(JSON.stringify({
                action: 'get_users',
                user_id: userId
            }));

            tg.onEvent('webAppData', function(data) {
                try {
                    const friends = JSON.parse(data.data);
                    displayFriendsList(friends);
                } catch (e) {
                    console.error('Do\'stlar ro\'yxatini yuklashda xatolik:', e);
                }
            });
        }

        function displayFriendsList(friends) {
            const friendsList = document.getElementById('friendsList');

            if (!friends || friends.length === 0) {
                friendsList.innerHTML = `
                    <div style="text-align: center; color: #f1c40f; padding: 20px;">
                        üòï Hozircha boshqa foydalanuvchilar yo'q.<br>
                        Botdan foydalanayotgan do'stlaringiz bo'lishi kerak!
                    </div>
                `;
                return;
            }

            friendsList.innerHTML = friends.map(friend => `
                <div class="friend-item ${friend.online ? 'online' : 'offline'}">
                    <div class="friend-info">
                        <span class="friend-name">${friend.name}</span>
                        <span class="friend-rating">‚òÖ ${friend[gameType + '_rating'] || 1200}</span>
                        <span class="friend-status">${friend.online ? 'üü¢ Online' : '‚ö´ Offline'}</span>
                    </div>
                    <button class="invite-btn" onclick="inviteFriend(${friend.id}, '${friend.name}')" ${!friend.online ? 'disabled' : ''}>
                        üì® Taklif qilish
                    </button>
                </div>
            `).join('');
        }

        function inviteFriend(friendId, friendName) {
            tg.sendData(JSON.stringify({
                action: 'invite_friend',
                from_id: userId,
                from_name: userName,
                to_id: friendId,
                game_type: gameType,
                room_code: roomCode
            }));

            showNotification(`‚úÖ Taklif ${friendName} ga yuborildi!`);

            setTimeout(() => {
                closeWebApp();
            }, 1500);
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function closeWebApp() {
            tg.sendData(JSON.stringify({
                action: 'close_webapp',
                user_id: userId,
                room_code: roomCode
            }));

            setTimeout(() => {
                tg.close();
            }, 100);
        }

        function showGame() {
            const app = document.getElementById('app');
            const aiInfo = aiLevels[aiLevel] || aiLevels[1];

            let opponentName = '';
            if (mode === 'ai') {
                opponentName = `AI ${aiInfo.icon} ${aiInfo.name}`;
            } else if (playerRole === 'host') {
                opponentName = 'Kutilyapti...';
            } else {
                opponentName = 'Do\'st';
            }

            app.innerHTML = `
                <div class="game-container">
                    <div class="game-title">${gameType === 'checkers' ? 'üéØ SHAHKA' : '‚ôüÔ∏è SHAXMAT'}</div>

                    ${mode === 'ai' ? `
                        <div class="ai-level-info">
                            <div>
                                <span class="ai-level-badge" style="background: ${aiInfo.color}">
                                    ${aiInfo.icon} ${aiInfo.name}
                                </span>
                                <div class="ai-level-desc">${aiInfo.desc}</div>
                            </div>
                            <div class="ai-level-name">${aiLevel}/5 daraja</div>
                        </div>
                    ` : ''}

                    <div class="players-panel">
                        <div class="player-section">
                            <span class="player-label">SIZ</span>
                            <span class="player-name" id="playerName">${userName}</span>
                            <span class="player-rating" id="playerRating">‚òÖ 1200</span>
                        </div>
                        <div class="vs-badge">VS</div>
                        <div class="player-section">
                            <span class="player-label">RAQIB</span>
                            <span class="player-name" id="opponentName">${opponentName}</span>
                            <span class="player-rating" id="opponentRating">
                                ${mode === 'ai' ? `‚òÖ ${aiInfo.rating}` : '‚òÖ 1200'}
                            </span>
                        </div>
                    </div>

                    <div class="board-wrapper">
                        <div id="board" class="board"></div>
                    </div>

                    <div id="status" class="status-bar">‚ö™ Sizning navbatingiz</div>

                    <div class="buttons-panel">
                        <button class="btn btn-exit" onclick="exitGame()">
                            <span>üö™</span> Chiqish
                        </button>
                        <button class="btn btn-restart" onclick="restartGame()">
                            <span>üîÑ</span> Qayta boshlash
                        </button>
                    </div>
                </div>

                <div id="winnerModal" class="winner-modal">
                    <div class="winner-content">
                        <h2>üèÜ G'OLIB</h2>
                        <p id="winnerName">O'yinchi</p>
                        <div class="winner-buttons">
                            <button class="winner-btn restart" onclick="restartGameAfterWin()">üîÑ Qayta</button>
                            <button class="winner-btn exit" onclick="exitGame()">üö™ Chiqish</button>
                        </div>
                    </div>
                </div>
            `;

            initGame();
        }

        function exitGame() {
            if (!gameActive && winner) {
                const isWinner = (winner === userName);
                tg.sendData(JSON.stringify({
                    action: 'game_over',
                    user_id: userId,
                    winner_id: isWinner ? userId : null,
                    game_type: gameType,
                    ai_level: mode === 'ai' ? aiLevel : null,
                    room_code: roomCode
                }));
            }

            closeWebApp();
        }

        // ==================== O'YIN LOGIKASI ====================
        let board = [];
        let currentPlayer = 1;
        let selectedPiece = null;
        let validMoves = [];
        let gameActive = true;
        let aiThinking = false;
        let winner = null;

        function initBoard() {
            board = [
                [0,2,0,2,0,2,0,2],
                [2,0,2,0,2,0,2,0],
                [0,2,0,2,0,2,0,2],
                [0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0],
                [1,0,1,0,1,0,1,0],
                [0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0]
            ];
        }

        function initGame() {
            initBoard();
            renderBoard();

            if (mode === 'ai' && aiLevel >= 4 && Math.random() > 0.5) {
                setTimeout(makeAIMove, 1000);
            }
        }

        function renderBoard() {
            const boardElement = document.getElementById('board');
            if (!boardElement) return;

            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    const piece = board[row][col];

                    if (piece > 0) {
                        const pieceDiv = document.createElement('div');
                        const isWhite = (piece === 1 || piece === 3);
                        pieceDiv.className = `piece ${isWhite ? 'white' : 'black'}`;

                        if (piece === 3 || piece === 4) {
                            pieceDiv.classList.add('king');
                        }

                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                            pieceDiv.classList.add('selected');
                        }

                        if (gameActive && currentPlayer === 1 && isWhite) {
                            pieceDiv.onclick = (e) => {
                                e.stopPropagation();
                                selectPiece(row, col);
                            };
                        }

                        cell.appendChild(pieceDiv);
                    } else {
                        if (gameActive && currentPlayer === 1) {
                            cell.onclick = () => handleCellClick(row, col);
                        }
                    }

                    boardElement.appendChild(cell);
                }
            }

            if (selectedPiece && validMoves.length > 0) {
                showValidMoves();
            }
        }

        function selectPiece(row, col) {
            const allCaptures = getAllCaptures(1);
            if (allCaptures.length > 0) {
                const pieceCaptures = allCaptures.filter(m => m.fromRow === row && m.fromCol === col);
                if (pieceCaptures.length === 0) {
                    showNotification('‚ö†Ô∏è Avval zarba berishingiz kerak!');
                    return;
                }
                validMoves = pieceCaptures;
            } else {
                const moves = getValidMoves(row, col);
                if (moves.length === 0) return;
                validMoves = moves;
            }

            selectedPiece = { row, col };
            renderBoard();
        }

        function showValidMoves() {
            validMoves.forEach(move => {
                const cells = document.querySelectorAll('.cell');
                const index = move.toRow * 8 + move.toCol;
                if (cells[index]) {
                    const hint = document.createElement('div');
                    hint.className = move.isCapture ? 'capture-hint' : 'hint';
                    cells[index].appendChild(hint);
                }
            });
        }

        function handleCellClick(row, col) {
            if (!selectedPiece) return;

            const move = validMoves.find(m => m.toRow === row && m.toCol === col);
            if (move) {
                makeMove(move);
            } else {
                selectedPiece = null;
                validMoves = [];
                renderBoard();
            }
        }

        function getAllCaptures(playerColor) {
            const captures = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    const isWhite = (piece === 1 || piece === 3);
                    if (piece > 0 && isWhite === (playerColor === 1)) {
                        const pieceCaptures = findCaptures(row, col, piece, (piece === 3 || piece === 4), isWhite);
                        captures.push(...pieceCaptures);
                    }
                }
            }
            return captures;
        }

        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (piece === 0) return [];

            const isKing = (piece === 3 || piece === 4);
            const isWhite = (piece === 1 || piece === 3);

            const captureMoves = findCaptures(row, col, piece, isKing, isWhite);

            const allCaptures = getAllCaptures(isWhite ? 1 : 2);
            if (allCaptures.length > 0) {
                return captureMoves;
            }

            const moves = [];
            const directions = isKing ? [[-1,-1], [-1,1], [1,-1], [1,1]]
                                    : (isWhite ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]]);

            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;

                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    if (board[newRow][newCol] === 0) {
                        moves.push({
                            fromRow: row,
                            fromCol: col,
                            toRow: newRow,
                            toCol: newCol,
                            isCapture: false
                        });
                    }
                }
            }

            return moves;
        }

        function findCaptures(row, col, piece, isKing, isWhite) {
            const captures = [];
            const directions = [[-1,-1], [-1,1], [1,-1], [1,1]];

            for (const [dr, dc] of directions) {
                if (isKing) {
                    let step = 1;
                    while (true) {
                        const midRow = row + dr * step;
                        const midCol = col + dc * step;
                        const jumpRow = row + dr * (step + 1);
                        const jumpCol = col + dc * (step + 1);

                        if (jumpRow < 0 || jumpRow >= 8 || jumpCol < 0 || jumpCol >= 8) break;

                        const midPiece = board[midRow]?.[midCol];
                        const jumpCell = board[jumpRow]?.[jumpCol];

                        if (midPiece > 0 && jumpCell === 0) {
                            const isMidWhite = (midPiece === 1 || midPiece === 3);
                            if (isWhite !== isMidWhite) {
                                captures.push({
                                    fromRow: row,
                                    fromCol: col,
                                    toRow: jumpRow,
                                    toCol: jumpCol,
                                    isCapture: true,
                                    capturedRow: midRow,
                                    capturedCol: midCol
                                });
                                break;
                            }
                        }

                        if (midPiece !== 0) break;
                        step++;
                    }
                } else {
                    const midRow = row + dr;
                    const midCol = col + dc;
                    const jumpRow = row + dr * 2;
                    const jumpCol = col + dc * 2;

                    if (jumpRow >= 0 && jumpRow < 8 && jumpCol >= 0 && jumpCol < 8) {
                        const midPiece = board[midRow]?.[midCol];
                        const jumpCell = board[jumpRow]?.[jumpCol];

                        if (midPiece > 0 && jumpCell === 0) {
                            const isMidWhite = (midPiece === 1 || midPiece === 3);
                            if (isWhite !== isMidWhite) {
                                captures.push({
                                    fromRow: row,
                                    fromCol: col,
                                    toRow: jumpRow,
                                    toCol: jumpCol,
                                    isCapture: true,
                                    capturedRow: midRow,
                                    capturedCol: midCol
                                });
                            }
                        }
                    }
                }
            }

            return captures;
        }

        function makeMove(move) {
            const piece = board[move.fromRow][move.fromCol];

            board[move.fromRow][move.fromCol] = 0;
            board[move.toRow][move.toCol] = piece;

            if (move.isCapture) {
                board[move.capturedRow][move.capturedCol] = 0;

                const nextCaptures = findCaptures(
                    move.toRow, move.toCol, piece,
                    (piece === 3 || piece === 4),
                    (piece === 1 || piece === 3)
                );

                if (nextCaptures.length > 0) {
                    selectedPiece = { row: move.toRow, col: move.toCol };
                    validMoves = nextCaptures;
                    renderBoard();
                    return;
                }
            }

            if (piece === 1 && move.toRow === 0) {
                board[move.toRow][move.toCol] = 3;
            } else if (piece === 2 && move.toRow === 7) {
                board[move.toRow][move.toCol] = 4;
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            selectedPiece = null;
            validMoves = [];

            checkGameOver();
            renderBoard();
            updateStatus();

            if (mode === 'ai') {
                saveGameState();
            }

            if (mode === 'ai' && currentPlayer === 2 && gameActive) {
                setTimeout(makeAIMove, 500 + (aiLevel * 100));
            }
        }

        function makeAIMove() {
            if (aiThinking || !gameActive) return;
            aiThinking = true;

            const aiPieces = [];
            const aiCaptures = [];

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece === 2 || piece === 4) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            const captures = moves.filter(m => m.isCapture);
                            if (captures.length > 0) {
                                aiCaptures.push(...captures);
                            } else {
                                aiPieces.push(...moves);
                            }
                        }
                    }
                }
            }

            let selectedMove = null;

            if (aiCaptures.length > 0) {
                switch(aiLevel) {
                    case 1:
                        selectedMove = aiCaptures[Math.floor(Math.random() * aiCaptures.length)];
                        break;

                    case 2:
                        selectedMove = aiCaptures.reduce((best, move) => {
                            const piece = board[move.toRow][move.toCol];
                            const nextCaptures = findCaptures(
                                move.toRow, move.toCol, piece,
                                (piece === 4), false
                            ).length;
                            return nextCaptures > (best.nextCaptures || 0) ?
                                   {...move, nextCaptures} : best;
                        }, {nextCaptures: -1});
                        break;

                    case 3:
                        selectedMove = aiCaptures.reduce((best, move) => {
                            let score = 0;
                            if (move.toRow === 0) score += 10;
                            const piece = board[move.toRow][move.toCol];
                            const nextCaptures = findCaptures(
                                move.toRow, move.toCol, piece,
                                (piece === 4), false
                            ).length;
                            score += nextCaptures * 5;
                            return score > (best.score || 0) ? {...move, score} : best;
                        }, {score: -1});
                        break;

                    case 4:
                    case 5:
                        selectedMove = aiCaptures.reduce((best, move) => {
                            let score = 0;
                            const centerDist = Math.abs(move.toCol - 3.5);
                            score += (4 - centerDist) * 2;
                            if (move.toRow === 0) score += 15;
                            const piece = board[move.toRow][move.toCol];
                            const nextCaptures = findCaptures(
                                move.toRow, move.toCol, piece,
                                (piece === 4), false
                            ).length;
                            score += nextCaptures * 8;
                            for (let r = 0; r < 8; r++) {
                                for (let c = 0; c < 8; c++) {
                                    if (board[r][c] === 1 || board[r][c] === 3) {
                                        const dist = Math.abs(move.toRow - r) + Math.abs(move.toCol - c);
                                        if (dist <= 2) score += 3;
                                    }
                                }
                            }
                            return score > (best.score || 0) ? {...move, score} : best;
                        }, {score: -1});
                        break;
                }
            } else if (aiPieces.length > 0) {
                switch(aiLevel) {
                    case 1:
                    case 2:
                        selectedMove = aiPieces[Math.floor(Math.random() * aiPieces.length)];
                        break;

                    case 3:
                        selectedMove = aiPieces.reduce((best, move) => {
                            const centerDist = Math.abs(move.toCol - 3.5);
                            const score = 4 - centerDist;
                            return score > (best.score || 0) ? {...move, score} : best;
                        }, {score: -1});
                        break;

                    case 4:
                        selectedMove = aiPieces.reduce((best, move) => {
                            let score = 0;
                            if (move.toRow > 4) score += 3;
                            const centerDist = Math.abs(move.toCol - 3.5);
                            score += (4 - centerDist);
                            for (const [dr, dc] of [[-1,-1], [-1,1], [1,-1], [1,1]]) {
                                const nr = move.toRow + dr;
                                const nc = move.toCol + dc;
                                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                    if (board[nr][nc] === 2 || board[nr][nc] === 4) {
                                        score += 2;
                                    }
                                }
                            }
                            return score > (best.score || 0) ? {...move, score} : best;
                        }, {score: -1});
                        break;

                    case 5:
                        selectedMove = aiPieces.reduce((best, move) => {
                            let score = 0;
                            score += 8 - move.toRow;
                            const centerDist = Math.abs(move.toCol - 3.5);
                            score += (4 - centerDist) * 2;

                            const tempBoard = JSON.parse(JSON.stringify(board));
                            tempBoard[move.toRow][move.toCol] = tempBoard[move.fromRow][move.fromCol];
                            tempBoard[move.fromRow][move.fromCol] = 0;

                            const futureCaptures = findCaptures(
                                move.toRow, move.toCol,
                                tempBoard[move.toRow][move.toCol],
                                (tempBoard[move.toRow][move.toCol] === 4), false
                            );
                            score += futureCaptures.length * 5;

                            return score > (best.score || 0) ? {...move, score} : best;
                        }, {score: -1});
                        break;
                }
            }

            if (selectedMove) {
                makeMove(selectedMove);
            } else {
                gameActive = false;
                winner = userName;
                showWinner(userName);
            }

            aiThinking = false;
        }

        function checkGameOver() {
            let whiteExists = false;
            let blackExists = false;
            let whiteMoves = false;
            let blackMoves = false;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece === 1 || piece === 3) {
                        whiteExists = true;
                        if (getValidMoves(row, col).length > 0) {
                            whiteMoves = true;
                        }
                    }
                    if (piece === 2 || piece === 4) {
                        blackExists = true;
                        if (getValidMoves(row, col).length > 0) {
                            blackMoves = true;
                        }
                    }
                }
            }

            if (!whiteExists || (whiteExists && !whiteMoves)) {
                gameActive = false;
                winner = mode === 'ai' ? 'AI' : (playerRole === 'host' ? 'Mehmon' : 'Xona egasi');
                showWinner(winner);
            } else if (!blackExists || (blackExists && !blackMoves)) {
                gameActive = false;
                winner = userName;
                showWinner(userName);
            }
        }

        function updateStatus() {
            const statusElement = document.getElementById('status');
            if (!statusElement) return;

            if (!gameActive) return;

            if (mode === 'ai') {
                if (currentPlayer === 1) {
                    statusElement.innerHTML = "‚ö™ Sizning navbatingiz";
                } else {
                    const aiInfo = aiLevels[aiLevel];
                    statusElement.innerHTML = `‚ö´ ${aiInfo.icon} AI navbati (${aiInfo.name})`;
                }
            } else {
                if (currentPlayer === 1) {
                    statusElement.innerHTML = "‚ö™ Sizning navbatingiz";
                } else {
                    statusElement.innerHTML = "‚ö´ Raqib navbati";
                }
            }
        }

        function showWinner(winnerName) {
            const modal = document.getElementById('winnerModal');
            const nameElement = document.getElementById('winnerName');
            if (modal && nameElement) {
                nameElement.textContent = winnerName;
                modal.style.display = 'flex';

                const isWinner = (winnerName === userName);
                tg.sendData(JSON.stringify({
                    action: 'game_over',
                    user_id: userId,
                    winner_id: isWinner ? userId : null,
                    game_type: gameType,
                    ai_level: mode === 'ai' ? aiLevel : null,
                    room_code: roomCode
                }));
            }
        }

        function closeWinnerModal() {
            const modal = document.getElementById('winnerModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function restartGameAfterWin() {
            closeWinnerModal();
            restartGame();
        }

        function restartGame() {
            initBoard();
            currentPlayer = 1;
            selectedPiece = null;
            validMoves = [];
            gameActive = true;
            aiThinking = false;
            winner = null;
            renderBoard();
            updateStatus();

            localStorage.removeItem(`currentGame_${gameType}_${mode}_${aiLevel}`);
        }
    </script>
</body>
</html>